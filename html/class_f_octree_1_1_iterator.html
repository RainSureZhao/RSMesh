<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RSMesh: FOctree&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RSMesh<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">一个曲面重构的系统，输入为点云，输出为obj,stl等主流格式的网格文件，使用的方法为径向基函数插值，采取了并行优化、Intel-MKL等优化措施，支持百万级别的点云</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="class_f_octree.html">FOctree</a></li><li class="navelem"><a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="class_f_octree_1_1_iterator-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">FOctree&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator类 参考</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_f_octree_8hpp_source.html">FOctree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a228b2bcc7fd95a7304f31fd8aaf8b966" id="r_a228b2bcc7fd95a7304f31fd8aaf8b966"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a228b2bcc7fd95a7304f31fd8aaf8b966">Iterator</a> (<a class="el" href="class_f_octree.html">FOctree</a> *const inTarget)</td></tr>
<tr class="separator:a228b2bcc7fd95a7304f31fd8aaf8b966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e030851c965752a57633483d9b92c95" id="r_a5e030851c965752a57633483d9b92c95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e030851c965752a57633483d9b92c95">Iterator</a> (const <a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;other)</td></tr>
<tr class="separator:a5e030851c965752a57633483d9b92c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254749322b9259b9295c67467195b536" id="r_a254749322b9259b9295c67467195b536"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a254749322b9259b9295c67467195b536">Iterator</a> (<a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;&amp;other)</td></tr>
<tr class="separator:a254749322b9259b9295c67467195b536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a96569939ae1b4ebd766e5cd38a9575" id="r_a3a96569939ae1b4ebd766e5cd38a9575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a96569939ae1b4ebd766e5cd38a9575">operator=</a> (const <a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;other)</td></tr>
<tr class="separator:a3a96569939ae1b4ebd766e5cd38a9575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44bac37ec49352b1ae57c10dd38ae53" id="r_ac44bac37ec49352b1ae57c10dd38ae53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac44bac37ec49352b1ae57c10dd38ae53">operator=</a> (<a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ac44bac37ec49352b1ae57c10dd38ae53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move operator  <br /></td></tr>
<tr class="separator:ac44bac37ec49352b1ae57c10dd38ae53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b310f24e5d6d9f83f29762dcde67936" id="r_a7b310f24e5d6d9f83f29762dcde67936"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b310f24e5d6d9f83f29762dcde67936">operator==</a> (const <a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;other) const</td></tr>
<tr class="memdesc:a7b310f24e5d6d9f83f29762dcde67936"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality operator  <br /></td></tr>
<tr class="separator:a7b310f24e5d6d9f83f29762dcde67936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e2aa2625fdd91929226c03d4eae834" id="r_a84e2aa2625fdd91929226c03d4eae834"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84e2aa2625fdd91929226c03d4eae834">operator!=</a> (const <a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;other) const</td></tr>
<tr class="memdesc:a84e2aa2625fdd91929226c03d4eae834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator  <br /></td></tr>
<tr class="separator:a84e2aa2625fdd91929226c03d4eae834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daf2034c5a8d329b6e24af8d22da1da" id="r_a8daf2034c5a8d329b6e24af8d22da1da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8daf2034c5a8d329b6e24af8d22da1da">gotoTop</a> ()</td></tr>
<tr class="separator:a8daf2034c5a8d329b6e24af8d22da1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da91ea283e61575f6e96b9f11bb28f3" id="r_a7da91ea283e61575f6e96b9f11bb28f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7da91ea283e61575f6e96b9f11bb28f3">gotoBottomLeft</a> ()</td></tr>
<tr class="separator:a7da91ea283e61575f6e96b9f11bb28f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e82bca73dc40d2cc7955e00f281a7a" id="r_a78e82bca73dc40d2cc7955e00f281a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78e82bca73dc40d2cc7955e00f281a7a">gotoLeft</a> ()</td></tr>
<tr class="separator:a78e82bca73dc40d2cc7955e00f281a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e70771f86a71768f776dc2fcc3fb273" id="r_a7e70771f86a71768f776dc2fcc3fb273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e70771f86a71768f776dc2fcc3fb273">gotoRight</a> ()</td></tr>
<tr class="separator:a7e70771f86a71768f776dc2fcc3fb273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372eaea436f11838a3618721c60ad97e" id="r_a372eaea436f11838a3618721c60ad97e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a372eaea436f11838a3618721c60ad97e">moveRight</a> ()</td></tr>
<tr class="separator:a372eaea436f11838a3618721c60ad97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf33ffc63fdd67f8469ce62026fe84d" id="r_accf33ffc63fdd67f8469ce62026fe84d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accf33ffc63fdd67f8469ce62026fe84d">moveUp</a> ()</td></tr>
<tr class="separator:accf33ffc63fdd67f8469ce62026fe84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6352805438c6e8bee5c14580a952a2" id="r_abf6352805438c6e8bee5c14580a952a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf6352805438c6e8bee5c14580a952a2">moveDown</a> ()</td></tr>
<tr class="separator:abf6352805438c6e8bee5c14580a952a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33808b0b322d221abd54779d4b946cb0" id="r_a33808b0b322d221abd54779d4b946cb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33808b0b322d221abd54779d4b946cb0">canProgressToUp</a> () const</td></tr>
<tr class="separator:a33808b0b322d221abd54779d4b946cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb66369b7e8b39d9f539f9f36dd6ca93" id="r_abb66369b7e8b39d9f539f9f36dd6ca93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb66369b7e8b39d9f539f9f36dd6ca93">canProgressToDown</a> () const</td></tr>
<tr class="separator:abb66369b7e8b39d9f539f9f36dd6ca93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac550b9455df8c580bbb7e1e6d30f78a6" id="r_ac550b9455df8c580bbb7e1e6d30f78a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac550b9455df8c580bbb7e1e6d30f78a6">isAtLeafLevel</a> () const</td></tr>
<tr class="separator:ac550b9455df8c580bbb7e1e6d30f78a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc816b9ee59b4d2e882eb68761de3cd" id="r_aedc816b9ee59b4d2e882eb68761de3cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedc816b9ee59b4d2e882eb68761de3cd">level</a> () const</td></tr>
<tr class="separator:aedc816b9ee59b4d2e882eb68761de3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dee8812ea4822ac25f8c5c0e852272" id="r_a20dee8812ea4822ac25f8c5c0e852272"><td class="memItemLeft" align="right" valign="top">LeafClass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20dee8812ea4822ac25f8c5c0e852272">getCurrentLeaf</a> () const</td></tr>
<tr class="separator:a20dee8812ea4822ac25f8c5c0e852272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc83dd046da9b65371bae7249f774b5" id="r_a5bc83dd046da9b65371bae7249f774b5"><td class="memItemLeft" align="right" valign="top">ContainerClass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bc83dd046da9b65371bae7249f774b5">getCurrentListSrc</a> () const</td></tr>
<tr class="separator:a5bc83dd046da9b65371bae7249f774b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84ddf663d0a378634bfd2c214c1d7d1" id="r_ac84ddf663d0a378634bfd2c214c1d7d1"><td class="memItemLeft" align="right" valign="top">ContainerClass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac84ddf663d0a378634bfd2c214c1d7d1">getCurrentListTargets</a> () const</td></tr>
<tr class="separator:ac84ddf663d0a378634bfd2c214c1d7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a46f6c9166281b21d3cd1b9a9ba2a8e" id="r_a4a46f6c9166281b21d3cd1b9a9ba2a8e"><td class="memItemLeft" align="right" valign="top">CellClass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a46f6c9166281b21d3cd1b9a9ba2a8e">getCurrentCell</a> () const</td></tr>
<tr class="separator:a4a46f6c9166281b21d3cd1b9a9ba2a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab247592f431f438721a8c43d37b34543" id="r_ab247592f431f438721a8c43d37b34543"><td class="memItemLeft" align="right" valign="top">CellClass **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab247592f431f438721a8c43d37b34543">getCurrentChild</a> () const</td></tr>
<tr class="separator:ab247592f431f438721a8c43d37b34543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee816111fcdd6a7b818bf5b618bbdf8" id="r_abee816111fcdd6a7b818bf5b618bbdf8"><td class="memItemLeft" align="right" valign="top">CellClass **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abee816111fcdd6a7b818bf5b618bbdf8">getCurrentChildren</a> () const</td></tr>
<tr class="separator:abee816111fcdd6a7b818bf5b618bbdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4de34326568eba5cdb1876a44c15cea" id="r_ad4de34326568eba5cdb1876a44c15cea"><td class="memItemLeft" align="right" valign="top">CellClass **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4de34326568eba5cdb1876a44c15cea">getCurrentBox</a> () const</td></tr>
<tr class="separator:ad4de34326568eba5cdb1876a44c15cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9a632dc85f6c32710af495619a71d7" id="r_a3d9a632dc85f6c32710af495619a71d7"><td class="memItemLeft" align="right" valign="top">MortonIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d9a632dc85f6c32710af495619a71d7">getCurrentGlobalIndex</a> () const</td></tr>
<tr class="separator:a3d9a632dc85f6c32710af495619a71d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074c602afb6739fb356d602bdc164d75" id="r_a074c602afb6739fb356d602bdc164d75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_f_tree_coordinate.html">FTreeCoordinate</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a074c602afb6739fb356d602bdc164d75">getCurrentGlobalCoordinate</a> () const</td></tr>
<tr class="separator:a074c602afb6739fb356d602bdc164d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class FReal, class CellClass, class ContainerClass, class LeafClass, class CellAllocatorClass = FBasicBlockAllocator&lt;CellClass&gt;&gt;<br />
class FOctree&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator</div><p>This has to be used to iterate on an octree It simply stores an pointer on a suboctree and moves to right/left/up/down. Please refer to testOctreeIter file to see how it works.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_f_octree_1_1_iterator.html">FOctree&lt;TestParticle, TestCell, NbLevels, NbSubLevels&gt;::Iterator</a> octreeIterator(&amp;tree);</div>
<div class="line">octreeIterator.gotoBottomLeft();</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> idx = 0 ; idx &lt; NbLevels - 1; ++idx ){</div>
<div class="line">    <span class="keywordflow">do</span>{</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    } <span class="keywordflow">while</span>(octreeIterator.moveRight());</div>
<div class="line">    octreeIterator.moveUp();</div>
<div class="line">    octreeIterator.gotoLeft();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_f_octree_1_1_iterator_html"><div class="ttname"><a href="class_f_octree_1_1_iterator.html">FOctree::Iterator</a></div><div class="ttdef"><b>Definition</b> FOctree.hpp:262</div></div>
</div><!-- fragment --><p> Remark : It uses the left right limit on each suboctree and their morton index. Please have a look to the move functions to understand how the system is working. </p>
</div><h2 class="groupheader">构造及析构函数说明</h2>
<a id="a228b2bcc7fd95a7304f31fd8aaf8b966" name="a228b2bcc7fd95a7304f31fd8aaf8b966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228b2bcc7fd95a7304f31fd8aaf8b966">&#9670;&#160;</a></span>Iterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::Iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_f_octree.html">FOctree</a> *const</td>          <td class="paramname"><span class="paramname"><em>inTarget</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">inTarget</td><td>the octree to iterate on After building a iterator, this one is positioned at the level 0 of the root (level 1 of octree) at the left limit index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e030851c965752a57633483d9b92c95" name="a5e030851c965752a57633483d9b92c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e030851c965752a57633483d9b92c95">&#9670;&#160;</a></span>Iterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::Iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>source iterator to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a254749322b9259b9295c67467195b536" name="a254749322b9259b9295c67467195b536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254749322b9259b9295c67467195b536">&#9670;&#160;</a></span>Iterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::Iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>source iterator to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="abb66369b7e8b39d9f539f9f36dd6ca93" name="abb66369b7e8b39d9f539f9f36dd6ca93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb66369b7e8b39d9f539f9f36dd6ca93">&#9670;&#160;</a></span>canProgressToDown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::canProgressToDown </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To know if we are not on the leafs level </p><dl class="section return"><dt>返回</dt><dd>true if we can move down </dd></dl>

</div>
</div>
<a id="a33808b0b322d221abd54779d4b946cb0" name="a33808b0b322d221abd54779d4b946cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33808b0b322d221abd54779d4b946cb0">&#9670;&#160;</a></span>canProgressToUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::canProgressToUp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To know if we are not on the root level </p><dl class="section return"><dt>返回</dt><dd>true if we can move up </dd></dl>

</div>
</div>
<a id="ad4de34326568eba5cdb1876a44c15cea" name="ad4de34326568eba5cdb1876a44c15cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4de34326568eba5cdb1876a44c15cea">&#9670;&#160;</a></span>getCurrentBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CellClass ** <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::getCurrentBox </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the part of array that contains all the pointers </p>

</div>
</div>
<a id="a4a46f6c9166281b21d3cd1b9a9ba2a8e" name="a4a46f6c9166281b21d3cd1b9a9ba2a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a46f6c9166281b21d3cd1b9a9ba2a8e">&#9670;&#160;</a></span>getCurrentCell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CellClass * <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::getCurrentCell </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current pointed cell </p><dl class="section return"><dt>返回</dt><dd>current cell element </dd></dl>

</div>
</div>
<a id="ab247592f431f438721a8c43d37b34543" name="ab247592f431f438721a8c43d37b34543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab247592f431f438721a8c43d37b34543">&#9670;&#160;</a></span>getCurrentChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CellClass ** <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::getCurrentChild </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the children of the current cell.</p>
<p>This function return an array of 8 CellClass. To know whether a child cell exists or not, the pointer must be checked.</p>
<dl class="section return"><dt>返回</dt><dd>the 8-child array. </dd></dl>

</div>
</div>
<a id="abee816111fcdd6a7b818bf5b618bbdf8" name="abee816111fcdd6a7b818bf5b618bbdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee816111fcdd6a7b818bf5b618bbdf8">&#9670;&#160;</a></span>getCurrentChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CellClass ** <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::getCurrentChildren </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the children of the current cell.</p>
<p>This function return an array of 8 CellClass. To know whether a child cell exists or not, the pointer must be checked.</p>
<dl class="section return"><dt>返回</dt><dd>the 8-child array. </dd></dl>

</div>
</div>
<a id="a074c602afb6739fb356d602bdc164d75" name="a074c602afb6739fb356d602bdc164d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074c602afb6739fb356d602bdc164d75">&#9670;&#160;</a></span>getCurrentGlobalCoordinate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_f_tree_coordinate.html">FTreeCoordinate</a> &amp; <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::getCurrentGlobalCoordinate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To get the tree coordinate of the current working cell </p>

</div>
</div>
<a id="a3d9a632dc85f6c32710af495619a71d7" name="a3d9a632dc85f6c32710af495619a71d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9a632dc85f6c32710af495619a71d7">&#9670;&#160;</a></span>getCurrentGlobalIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MortonIndex <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::getCurrentGlobalIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the Morton index of the current cell pointed by the iterator </p><dl class="section return"><dt>返回</dt><dd>The global morton index <code>iter.getCurrentGlobalIndex();<br  />
 // is equivalent to :<br  />
 iter.getCurrentCell()-&gt;getMortonIndex();</code> </dd></dl>

</div>
</div>
<a id="a20dee8812ea4822ac25f8c5c0e852272" name="a20dee8812ea4822ac25f8c5c0e852272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20dee8812ea4822ac25f8c5c0e852272">&#9670;&#160;</a></span>getCurrentLeaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LeafClass * <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::getCurrentLeaf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current pointed leaf </p><dl class="section return"><dt>返回</dt><dd>current leaf element </dd></dl>

</div>
</div>
<a id="a5bc83dd046da9b65371bae7249f774b5" name="a5bc83dd046da9b65371bae7249f774b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc83dd046da9b65371bae7249f774b5">&#9670;&#160;</a></span>getCurrentListSrc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ContainerClass * <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::getCurrentListSrc </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To access the current particles list You have to be at the leaf level to call this function! </p><dl class="section return"><dt>返回</dt><dd>current element list </dd></dl>

</div>
</div>
<a id="ac84ddf663d0a378634bfd2c214c1d7d1" name="ac84ddf663d0a378634bfd2c214c1d7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84ddf663d0a378634bfd2c214c1d7d1">&#9670;&#160;</a></span>getCurrentListTargets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ContainerClass * <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::getCurrentListTargets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To access the current particles list You have to be at the leaf level to call this function! </p><dl class="section return"><dt>返回</dt><dd>current element list </dd></dl>

</div>
</div>
<a id="a7da91ea283e61575f6e96b9f11bb28f3" name="a7da91ea283e61575f6e96b9f11bb28f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da91ea283e61575f6e96b9f11bb28f3">&#9670;&#160;</a></span>gotoBottomLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::gotoBottomLeft </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move iterator to the bottom left place We are on a leaf a the most left node the Algorithm is : first go to top then stay on the left and go downward </p>

</div>
</div>
<a id="a78e82bca73dc40d2cc7955e00f281a7a" name="a78e82bca73dc40d2cc7955e00f281a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e82bca73dc40d2cc7955e00f281a7a">&#9670;&#160;</a></span>gotoLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::gotoLeft </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move iterator to the left place at the same level if needed we go on another suboctree but we stay on at the same level the Algorithm is : go to top go downward until we are a the same level </p>

</div>
</div>
<a id="a7e70771f86a71768f776dc2fcc3fb273" name="a7e70771f86a71768f776dc2fcc3fb273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e70771f86a71768f776dc2fcc3fb273">&#9670;&#160;</a></span>gotoRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::gotoRight </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move iterator to the right place at the same level if needed we go on another suboctree but we stay on at the same level the Algorithm is : go to top go downward until we are a the same level </p>

</div>
</div>
<a id="a8daf2034c5a8d329b6e24af8d22da1da" name="a8daf2034c5a8d329b6e24af8d22da1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daf2034c5a8d329b6e24af8d22da1da">&#9670;&#160;</a></span>gotoTop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::gotoTop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move iterator to the top! (level 0 of root suboctree, level 1 of octree) after this function : index = left limit at root level the Algorithm is : going to root suboctree going to the first level and most left node </p>

</div>
</div>
<a id="ac550b9455df8c580bbb7e1e6d30f78a6" name="ac550b9455df8c580bbb7e1e6d30f78a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac550b9455df8c580bbb7e1e6d30f78a6">&#9670;&#160;</a></span>isAtLeafLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::isAtLeafLevel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To know if we are on the leafs level </p><dl class="section return"><dt>返回</dt><dd>true if we are at the bottom of the tree </dd></dl>

</div>
</div>
<a id="aedc816b9ee59b4d2e882eb68761de3cd" name="aedc816b9ee59b4d2e882eb68761de3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc816b9ee59b4d2e882eb68761de3cd">&#9670;&#160;</a></span>level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::level </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To know the current level (not local but global) </p><dl class="section return"><dt>返回</dt><dd>the level in the entire octree </dd></dl>

</div>
</div>
<a id="abf6352805438c6e8bee5c14580a952a2" name="abf6352805438c6e8bee5c14580a952a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6352805438c6e8bee5c14580a952a2">&#9670;&#160;</a></span>moveDown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::moveDown </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move down It may cause to change the suboctree we are working on We point on the first child found from left to right in the above level </p><dl class="section return"><dt>返回</dt><dd>true if succeed </dd></dl>

</div>
</div>
<a id="a372eaea436f11838a3618721c60ad97e" name="a372eaea436f11838a3618721c60ad97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372eaea436f11838a3618721c60ad97e">&#9670;&#160;</a></span>moveRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::moveRight </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Goto the next value on the right at the same level</p>
<p>The algorithm here is : As long as we are on the right limit, go to the parent suboctree if we are on the root and on the right then return (there is no more data on the right)</p>
<p>After that point we do not know where we are but we know that there is some data on the right (without knowing our position!)</p>
<p>We gotoNext on the brother to find an allocated cell (-&gt;) for example if we are on index 2 we will look until 8 = 2 | 7 + 1 if we arrive a 8 without finding a cell we go upper and do the same we know we will find something because we are not at the right limit</p>
<p>We find an allocated cell. We have to go down, we go on the left child of this cells until : the current level if we did not have change the current suboctree or : the leaf level</p>
<p>In the second case, it means we need to change octree downward but it is easy because we can use the left limit!</p>
<dl class="section return"><dt>返回</dt><dd>true if we succeed to go to the right, else false </dd></dl>

</div>
</div>
<a id="accf33ffc63fdd67f8469ce62026fe84d" name="accf33ffc63fdd67f8469ce62026fe84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf33ffc63fdd67f8469ce62026fe84d">&#9670;&#160;</a></span>moveUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::moveUp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move to the upper level It may cause to change the suboctree we are working on but we are using the same morton index &gt;&gt; 3 </p><dl class="section return"><dt>返回</dt><dd>true if succeed </dd></dl>

</div>
</div>
<a id="a84e2aa2625fdd91929226c03d4eae834" name="a84e2aa2625fdd91929226c03d4eae834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e2aa2625fdd91929226c03d4eae834">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>True if the two oterators are the different, false otherwise. </dd></dl>

</div>
</div>
<a id="a3a96569939ae1b4ebd766e5cd38a9575" name="a3a96569939ae1b4ebd766e5cd38a9575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a96569939ae1b4ebd766e5cd38a9575">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp; <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>source iterator to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>this after copy </dd></dl>

</div>
</div>
<a id="ac44bac37ec49352b1ae57c10dd38ae53" name="ac44bac37ec49352b1ae57c10dd38ae53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44bac37ec49352b1ae57c10dd38ae53">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp; <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move operator </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Object to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>This object after move. </dd></dl>

</div>
</div>
<a id="a7b310f24e5d6d9f83f29762dcde67936" name="a7b310f24e5d6d9f83f29762dcde67936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b310f24e5d6d9f83f29762dcde67936">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FReal , class CellClass , class ContainerClass , class LeafClass , class CellAllocatorClass  = FBasicBlockAllocator&lt;CellClass&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_f_octree.html">FOctree</a>&lt; FReal, CellClass, ContainerClass, LeafClass, CellAllocatorClass &gt;::Iterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equality operator </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="class_f_octree_1_1_iterator.html">Iterator</a> to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>True if the two oterators are the same, false otherwise. </dd></dl>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>third_party/ScalFMM/include/ScalFMM/Containers/<a class="el" href="_f_octree_8hpp_source.html">FOctree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
